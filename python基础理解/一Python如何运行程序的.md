#### 一。python 之所以功能强大，是因为它丰富的工具集和系统语言
```http
（1）动态类型：
    Python在运行过程中随时跟踪对象的种类，不需要代码中关于复杂的类型和大小的声明，事实上Python中没有类型和变量声明这回事，因为Python代码不是约束数据的类型，它往往自动的应用了一种广义上的对象。
    Python强大我认为还有一点就是它的自省，自省是指这种能力：检查某些事物以确定它是什么、它知道什么以及它能做什么。自省向程序员提供了极大的灵活性和控制力。简单来说就是运行时能够获得对象的类型。
（2）自动内存管理
    Python自动进行对象分配，当对象不再使用时，将自动撤销对象（'垃圾回收'），
    当需要时自动扩展或收缩，Python能够代替你进行底层的内存管理。
（3）大型程序的支持
    Python 包含了模块、类和异常等工具，这些工具允许你把系统组织为组件，使用OOP重用并定制代码，并以一种优雅的方式处理事件和错误
（4）内置对象类型
    Python提供了常用的数据结构作为语言的基本组成部分。例如：列表（list）、字典（dictionary）、字符串（string）。我们将会看到，它们灵活并易于使用，例如，内置对象可以根据需求扩展或收缩，可以任意地组织复杂的信息等。
（5）内置工具
    为了对以上对象类型进行处理，Python自带了许多强大的标准操作，包括合并（concatenation）、分片（slice）、排序（sort）和映射（mapping）等
（6）库工具
    Python预置了许多预编码的库工具，从正则表达式匹配到网络都支持
（7）第三方工具
    数据处理的：http://www.sohu.com/a/232660207_464033
    常用的第三方库： http://www.cnblogs.com/jiangchunsheng/p/9275881.html

```
#### 二。Python解释器简介
```http
当我们编写Python代码时，我们得到的是一个包含Python代码的以.py为扩展名的文本文件。要运行代码，就需要Python解释器去执行.py文件。
由于整个Python语言从规范到解释器都是开源的，所以理论上，只要水平够高，任何人都可以编写Python解释器来执行Python代码（当然难度很大）。事实上，确实存在多种Python解释器。

CPython
当我们从Python官方网站下载并安装好Python 2.7后，我们就直接获得了一个官方版本的解释器：CPython。这个解释器是用C语言开发的，所以叫CPython。在命令行下运行python就是启动CPython解释器。
CPython是使用最广的Python解释器。教程的所有代码也都在CPython下执行。

IPython
IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了IE。

CPython用>>>作为提示符，而IPython用In [序号]:作为提示符。

PyPy
PyPy是另一个Python解释器，它的目标是执行速度。PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。
绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。如果你的代码要放到PyPy下执行，就需要了解PyPy和CPython的不同点。

Jython
Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。

IronPython
IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。

小结
Python的解释器很多，但使用最广泛的还是CPython。如果要和Java或.Net平台交互，最好的办法不是用Jython或IronPython，而是通过网络调用来交互，确保各程序之间的独立性。
本教程的所有代码只确保在CPython 2.7版本下运行。请务必在本地安装CPython（也就是从Python官方网站下载的安装程序）。
此外，教程还内嵌一个IPython的Web版本，用来在浏览器内练习执行一些Python代码。要注意两者功能一样，输入的代码一样，但是提示符有所不同。另外，不是所有代码都能在Web版本的IPython中执行，出于安全原因，很多操作（比如文件操作）是受限的，所以有些代码必须在本地环境执行代码。

```
##### 字节码编译 ".pyc"就是编译过来的".py"源代码
#### 三。Python虚拟机（PVM）
```
PVM就是迭代运行字节码指令的一个大循环，一个接一个地完成操作，它是实际运行脚本的组件，也就是所谓Python解释器的最后一步
```
#### 经常出现的困惑与解答
```http
1. 什么是Python解释器？
  Python解释器是运行Python程序的程序。
2. 什么是源代码？
  源代码是为程序所写的语句：它包括了文本文件（通常以.py为后缀名）的文本。
3. 什么是字节码？
  字节码是Python将程序编译后所得到的底层形式。Python自动将字节码保存到后缀为.pyc的文件中。
4.什么是PVM？
  PVM是Python虚拟机，它是Python运行时引擎解释编译得到的代码。
5.请列出两个Python标准执行模块的变体的名字。
  Psyco（实时编译器，加快执行速度）、Shedskin（C++转换器）以及forzen biinaries（冻结二进制文件） 是执行模块的所有变体。
6. CPython、Jython以及IronPython有什么不同？
  CPython是Python语言的标准实现。Jython和IronPython分别是Python程序的Java和.net的实现；它们都是Python的编译器的替代实现

```

```http
7.怎样才能开始一个交互式解释器的会话？
  1）在windows下通过点击"开始"按钮，选择"程序"，点击"python"，然后选择"cmd.exe" 然后输入Python，开始交互式会话窗口
  2）启动IDLE，它就是Python shell窗口
8.你应该在哪里输入系统命令来启动一个脚本文件？
  在输入命令行的地方，也就是你所在的平台提供给作为系统终端的地方，‘黑窗口’
9.指出运行保存在一个脚本文件中的代码？
  一个脚本（实际上就是模块）文件中的代码可以通过系统命令、文件鼠标点击、导入和重载、exec内置函数以及像IDLE的Run等
10.指出在windows下点击图标运行脚本的两个缺点：
  打印后退出的脚本会导致输出的文件马上消失
11.在IDLE中怎么运行一个脚本？
  pycharm其实就是一个IDE
12.什么是命名空间，它和模块文件有什么关联？
  其实命名空间就是变量（也就是变量名）的封装，它在Python中以一个带有属性的对象的形式出现，每个模块文件自动成为一个命名空间：也就是说，一个对变量的封装，这些
  变量对应了顶层文件的赋值。命名空间可以避免在Python程序中的命名冲突--因为每个模块文件都是独立完备的命名空间，文件必须明确地导入其他的文件
```

### 看完需要理解几个知识点

```http
1.交互。
   使用系统命令行、IDLE或者其他的方法,开始Python交互命令行(>>>提示符),并输人表达式“Hello world“(包括引号)。这行字符申将会回显。这个练习的目的是确保已配置Python运行的环境。在某些情况下,你也许需要首先运行一条cdshell命令,输人Python可执行文件的完整路经,或者增加Python可执行文件的路径至PATH环境变量。如果想要的话,你可以在.chrc或.kshrc文件中设置PATH,使Python在UNIX系统中永久可用,在Windows中,使用serup.bar、axioexec.bal或者环境变量GUI。
2.程序。
   使用你选择的文本编辑器,写一个简单的包含了单个打印“Hellomoduleworldl“语句的模块文件,并将其保存为modulel.py。现在,通过使用任何你喜欢的启动选项来运行这个文件:在IDLE中运行,点击其文件图标,在系统shell的命令行中将其传递给Python解释器程序(例如,pythonmodulel.py)等。
3.模块。
   紧接着,开始一个Python交互命令行(>>>prompt)并导人你在练习2中所写的模块。试着将这个文件移动到一个不同的目录并再次从其原始的目录导人(也就是说,在刚才导人的目录运行Python)。
4.脚本
```

#### 疑难杂症--数据类型

```http
1.列举几个核心数据类型的名称
	数字、字符串、列表、字典、元组、文件和集合一般被认为是核心对象（数据）类型。类型、None和布尔值有时也被定义在这样的分类中。
2.为什么我们把它们称作'核心'数据类型？
	因为它们是Python语言自身的一部分，核心类型与Python的语法紧密的结合在一起
3."不可变性"代表了什么，哪三种Python的核心类型被认为是具有不可变性的？
	不可变性就是一个在创建后就不能改变的对象；
	数字、字符串、元组都具有不可变分类
4."序列"是什么意思，哪三种是Python的核心类型被认为是这个分类中的？
	序列是一个对位置进行排序的对象的集合；
	字符串、列表和元组都是序列，它们都有一个共同的特性，索引，合并以及分片，但是又有自己的类型特定的方法调用
5.序列化和反序列化
	序列化：利用pickle.dump，将对象写入到文件或者数据库中实现数据的持久化保存
	反序列化，就是利用pickle.load,将对象从文件中读取出来
6."映射"是什么意思，哪种Python的核心类型是映射？
	表示将键与相关的值相互关联映射的对象；
	字典就是Python核心类型集中唯一的映射类型，映射没有从左到右位置顺序，通过键来获取值的
7.什么是"多态"，为什么我们要关系多态？
	多态：不同对象调用相同方法产生不一样的结果，取决于被操作的对象
	不要把代码限制在特定的类型上，使代码自动适应多种类型
8.什么是重载、重写？
	重载就是就是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数和类型进行操作
	重写就是对已有的方法必须完全相同的方法进行修改，参数列表和返回的类型必须与被重写的方法相同
```

#### 对数据操作的以下的question

```http
1.python中表达式 2 *（3 + 4）的值是多少？
	14，因为括号强制让加法进行运行
2.Python中表达式 2 * 3 + 4 的值是多少？
	10，Python的操作优先级
3.Python中表达式 2 + 3 * 4 的值是多少？
	14，Python的操作优先级
4.通过什么工具你可以找到一个数字的平方根以及它的平方？
	导入math模块即可，
	一个数的平方根 math.sqrt(N),一个数的平方pow（x,2）/ x ** 2
5.表达式1 + 2.0 + 3 的结果是什么类型？
	浮点型float
6.怎样能够截断或舍去浮点数的小数部分？
	int(N)函数和math.trunc(N)函数都会省略小数部分
	round(N,digit)函数做四舍五入
	math.floor(N)来计算floor 向下取整
	math.ceil(N) 向上取整
7.怎样将一个整数转换为浮点数？
	float(I)
8.如何讲一个整数显示成八进制、十六进制或者二进制的形式？
	oct(I)  转换成八进制
	hex(I)  转换成十六进制
	bin(I)  转化成二进制
9.如何将一个八进制、十六进制或者二进制的字符串转换成平常整数？
	int(S,base) # base/8/16/2  S字符串
```

**动态数据类型问题**

```http
1.思考下面三条语句，它们会改变A打印出的值吗？
	A = 'span'
	B = A
	B = 'shrubbery'
	# 不改变，B只是引用了A，或者指向了A，B与A互不参连
	
2.下面三条语句，它们会改变A的值吗？
	A = ['span']
	B = A
	B[0] = 'shrubbery
	# 会改变，这两变量共同引用指向对象的一部分，
3.那下面的A会改变吗？
	A = ['span']
	B = A[:]
	B[0] = 'shrubbery'
	# 切片就相当于浅拷贝
	
```

**常用的数据类型(string)操作**

```http
1.字符串find方法能用于搜索列表吗？
	不行，因为方法是类型特定的，只能用于单一数据类型上
2.字符串切片表达式能用于列表吗？
	可以，表达式是通用的
3.你如何将字符转成ASCLL码的？
	ord(S)函数可将单个字符的字符串转化成字符编码
	chr(I)函数是将ascll码转成字符串
4.在Python中，怎么修改字符串？
	字符串是无法修改的，但是可以通过合并、切片运算、方法调用 创建新的字符串，在进行重新赋值
5.已知字符串S的值为"s,pa,m"提出两种从中间抽取两个字符的方式？
	(1)使用S[2:4]切片处理
	(2)使用S.split(',')[1]
6.字符串'a\nb\x1f\000d'之中有多少个字符？
	6个 字符串包含："a、新行(\n)、b、"
7.你为什么要使用string模块，而不使用字符串方法调用？
	Python3.0已经完全删除了，
```



**常用的数据类型(list字典)操作**

```http
1.举出两种方式来创建内含五个整数零的列表
	(1)[0]*5
	(2)l = [0 for i in range(5)]
	(3)l.append(0) # 需要不断书写
2.举出两种方式来创建一个字典，有两个键'a'和'b'，而每个键相关联的值都是0
	d = {key : value for (key,value) in iterable}
	dict1 = {}.fromkeys(('x','y'),-1) # {'x': -1, 'y': -1}
3.举出四种在原处修改列表对象的运算
	append/extend  可在原处增长
	sort/reverse  对列表进行排序或者翻转
	insert  可以在一个偏移值处查处一个元素
	remove/pop  会按照值的位置从列表中删除
	del 语句会删除一个元素或分片
4.举出四种在原处修改字典对象的运算
	del d['key'] 会删除一个键的元素
	update  会把一个字典合并到另一个字典
	D.pop(key)  则会移除一个键并返回它的值
	d.clear()  清除所有键值对
```

**关于元组的问题**

```http
1. 你怎么确定的元组有多大？
	len()
2.写一个表达式，修改元组的第一个元素。在此过程中（4,5,6）应该变成（1,5,6）
	元组不可变，如果必要就先转换成list修改完，以后再转换过来
3.open文件调用中，默认的处理模式自变量是什么？
	处理模式参数默认值为"r"：读取输入，对于输入文本文件，只要传入外部文件名即可
4.你可能使用什么模块把Python对象储存在文件中，而不是需要亲自将他们转换成字符串
	pickle 模块
	struct 模块
5.你怎么一次复制嵌套在结构的所有组成部分？
	如果需要复制嵌套结构的所有组成部分，就需要copy.deepcopy(X)
	一般情况下复制其行为就可以了，copy.copy(X)
6.Python在什么时候会认为一个对象为真？
	如果对象是非零数字或者非空集合体对象，就被认作是真
	用1 和 0 表示
	
```

**语法语句常遇见的问题**

```http
1.类C语言中需要哪三项在Python中省略了语法成分？
	测试两侧使用圆括号，每个语句末尾的分号，嵌套在代码块周围的大括号
2.Python中的语句一般都是怎样终止的？
	一般一行的结尾就是该执行语句的终止
3.Python中，嵌套代码块内的语句一般是如何关联在一起的？
	看代码中的缩进相同数目的制表符或空格
4.你怎么让一条语句跨过多行？
	语句可以横跨多行，只要将其封闭在圆括号内、方括号内和大括号内即可，当遇到闭合括号时，语句就会结束
5.你怎么在单个行上编写复合语句？
	复合语句的主体可以移到开头行的冒号后面，但前提是主体只由复合语句构成。
6.有什么理由要在Python语句末尾输入分号呢？
	表示结束
7.try语句是用来做什么的？
	用来捕捉和恢复异常（错误）
8.Python初学者常犯的编写代码错误是什么？
	忘记在复合语句开头行末尾输入冒号
```

**关于赋值、表达式的问题**

```http
1.列举出三种可以把三个变量赋值成相同的方式
	（1）a = b = c = 0
	（2）a, b, c = 0, 0, 0
	（3）a=0;b=0;c=0 写到一行
2.将三个变量赋值给可变对象时，需要注意什么？
	这三个变量名都会引用相同的对象，所以对期中一个变量名进行在原地的修改，也会影响到其他变量名。对不可变对象来讲，不会涉及到
3.L=L.sort()有什么错误？
	列表sort方法是对主体列表进行在原处的修改返回None
4.怎么使用print语句来向外部文件发送文本？
	print(X,file=F)调用形式
```

**关于if语法规则**

```http
1.在Python中怎样编写多路分支？
	if语句加多个elif分句
2.在Python中怎样把if/else语句写成表达式？
	Y if X else Z 在X为真时会返回Y，否则返回Z，这相当于4行if语句
3.怎样使得单个语句横跨多行？
	把语句包裹在语法括号中（()、[]或{}）,这样就可以按照需求跨多行
4.True和False这两个字代表了什么意义？
	可以用他们来测试
```

**while和for**

```http
1.while和for之间的主要功能区别是什么？
	while循环是一条通用的循环语句
	for循环设计用来在一个序列中遍历各项（要求可迭代的序列）
2.break和continue之间有何区别？
	break语句立即退出一个循环（省略下面的while或for语句）
	continue是跳出当前循环，然后返回顶部进行下次循环
3.一个循环的else分句何时执行？
	else分句会在循环离开时执行一次，但前提是循环是正常离开的，没有break
4.在Python中怎样编写一个基于计数器的循环？
	while  并手动记录索引值
	for 和range搭配
5.怎样使range用于for循环中？
	range内置函数可以用在一个for循环中来实现固定次数的重复
6.for循环和迭代器之间什么关系？
	for循环会使用迭代协议来遍历迭代的对象的每一项，for循环会每次迭代中调用该对象__next__方法（由next内置函数运行），而且会捕捉StopIteration异常，从而决定何时停止循环
7.for循环和列表解析之间有什么关系？
	两者都是迭代工具，列表解析是执行常见for循环任务的简明并且高效的方法
8.举出Python中的4种迭代环境
	for循环、列表解析、map内置函数、in成员关系、内置函数sorted、sum、any、all
9.如今从一个文本文件逐行读取行的最好方法是什么？
	for循环或者列表解析，然后让迭代工具在每次迭代中执行该文件的时候next
```

**文档**

```http
1.在什么时候应该使用文档字符串而不是#字注释?
	文档字符串主要用来描述程序中的模块、函数、类以及方法的使用
	#字注释只限于关于费解的表达式或语句的微型文档
2.举出3种查看文档字符串的方式。
	可以打印对象的__doc__属性，传给PyDoc的help函数
	PyDoc可以把模块的文档储存在HTML文件中以便稍后查看或打印
3.如何获得对象中可用属性的列表？
	内置的dir(X)函数会返回附加在任何对象上的所有属性的列表
4.如何获得计算机中所有可用模块的列表？
	执行PyDoc GUI接口，保持模块名称空白，然后选择"Open Browser"，这样会打开一个网页，其中包含了程序中每个可以模块的链接
	PyDoc用法：https://www.jianshu.com/p/af8eabb43cb8

```

**函数**

```http
1.编写函数有什么意义？
	避免代码的冗余最基本方式：把代码分解成函数，意味着未来只有一个运算的代码的拷贝需要更新
2.什么时候Python将会创建函数？
	当Python运行到并执行def语句时，函数就会被创建
3.当一个函数没有return语句时，他将返回什么？
	函数会传回None对象，并将None结果赋值给变量，通常是没有意义的
4.在函数定义内部的语句什么时候运行？
	函数主体（嵌套在函数定义语句中的代码）在函数稍后通过一个调用表达式调用时就会执行，函数每次被调用，主体都会全新运行一次
5.检查传入函数的对象类型有什么错误？
	检查传入函数的对象类型，实质上就是破坏函数的灵活性，把函数限制在特定的类型上。没有这类检查，函数可能处理所有的对象类型：任何支持函数所预期的接口的对象都能用（接口一词是指函数所执行的一组方法和表达式运算符）。
	
```

**作用域理解**

```http
1.下面的代码会输出什么？为什么？
	x = 'span'
	def func():
		print(x)
	func()
	这里输出的是span，
	因为函数引用的是模块中的全局变量
2.下面的代码会输出什么？为什么？
	x = 'span'
	def func():
		x = 'gg'
	func()
	print(x)
	输出是span，
	因为在函数中赋值变量会将其变成本地遍历，从而隐藏了同名的全局变量，print语句会找到没有发生改变的全局模块作用域中的变量
3.下面的代码会输出什么？为什么？
	x = 'span'
	def func():
		x = 'gg'
		print(x)
	func()
	print(x)
	一行会打印gg另一行会打印span，
	因为函数中引用的变量会找到其本地变量，而print中引用的变量会找到其全局变量
4.下面的代码会输出什么？为什么？
	x = 'span'
	def func():
		global x
		x = 'gg'
	func()
	print(x)
	输出gg
	因为全局声明会强制函数中赋值的变量引用其所在的全局作用域中的变量
5.下面的代码会输出什么？为什么？
	x = 'span'
    def func():
    	x = 'gg'
        def show():
        	print(x)
       	show()
    func()
    print(x)
    输出是gg gg
    因为嵌套函数中的print语句会在所在的函数本地作用域中发现变量名，而末尾的print会在全局作用域中发现这个变量
    
6.这段代码在Python3.0下会输出什么？为什么？
	def func():
		x = 'gg'
		def show():
			nonlocal x
			x = 'span'
		show()
		print(x)
	func()
	输出span，因为nonlocal语句意味着在嵌套函数中对x赋值，以修改嵌套函数的作用域中的x
	
7.举出三种或四种Python函数中保存状态信息的方法。
	global 、嵌套函数内的作用域引用  、 使用默认参数值来让一个Python函数保持状态信息
```

**参数**

```http
1.下面代码的输出是什么？为什么？
	def func(a, b=4, c=5):
		print(a, b, c)
	func(1, 2)
	1 2 5
	因为1,2按照位置传递给了a，b，并且c在调用中被忽略了，默认为5
2.下面代码的输出是什么？为什么？
	def func(a,b,c=5):
		print(a, b, c)
	func(1, c=3, b=2)
	1 2 3
	1传递给a，2,3按照名称传递给b，c（当像这样使用关键字参数的时候，从左到右的顺序无关紧要）
3.如下代码的输出是什么？为什么？
	def func(a,*pargs):
		print(a,pargs)
	func(1,2,3)
	1 (2, 3)
	1传递给a，pargs把其他的位置参数收集到一个新的元组对象中
4.如下代码打印会出什么？为什么？
	def func(a,**kargs):
		print(a,kargs)
	func(a=1,c=3,b=2)
	1 {'c': 3, 'b': 2}
	**kargs把关键字参数收集到一个字典中
5.最后一次运行时，下面代码的输出是什么？为什么？
	def func(a,b,c=3,d=4):
		print(a,b,c,d)
	func(1,*(5,6))
	1 5 6 4
	5,6按照name位置匹配b和c(6覆盖了c的默认值)，并且d默认值为4，它没有传递一个值
	
6.举出三种以上函数和调用者能够交流结果的方法
	return语句
	修改传入的可变参数
	设置全局变量
```

**函数的高阶**

```http
1.lambda表达式和def语句有什么关系？
	lambda和def都会创建函数对象，以便稍后调用。不过，因为lambda是表达式，可以嵌入函数定义中def语法上无法出现的地方，lambda只允许单个的返回值表达式，因为它不支持语句代码块，不支持较大的函数
2.使用lambda的要点是什么？
	lambda允许"内联"小单元可执行，推迟其执行，并以默认参数和封闭作用域的形式为其提供状态
3.比较和对比map，filter和reduce
	map把每一项传递给函数并收集结果，
	filter收集那些函数返回一个True值的项
	reduce通过对一个累加器和后续项应用函数来计算一个单个的值 reduce需要在from functools import reduce
4.什么是函数注解，如何使用它们？
	Python3.0以后可用，并且是函数的参数及其结果的语法上的装饰，它会收集到分配给函数的__annotations__属性的一个字典中，Python在这些注解上没有放置语义含义，而是直接将其包装，以供其他工具潜在的使用
5.什么是递归函数，如何使用它们？
	递归函数调用本身可以直接地或间接地进行，从而实现循环，它们可以用来遍历任何形状的结构，但是也可以用来进行一般性迭代
6.编写函数的通用设计规则是什么？
	函数通常应该较小，尽可能自包含，拥有单一的、统一的用途，并且与输入参数和返回值等其他部分通信，如果期待修改的话，它们可以使用可变参数来与结果通信，并且一些类型的程序暗含其他的通信机制。
	

```

**迭代和解析**

```http
1.列表解析放在方括号和圆括号中有什么区别？
	方括号中的列表解析会一次在内存中产生结果列表
	圆括号中不会一次产生结果列表，用在迭代环境中一次产生一个结果
2.生成器和迭代器有什么关系？
	生成器是支持迭代协议的对象：它们有__next__方法，重复前进到系列结果中的下个元素，以及到系列尾端时引发例外事件。
3.如何分辨函数是否为生成器函数？
	生成器函数在其代码中会有一个yield语句
4.yield语句是做什么的？
	yield会让Python把函数特定的编译生成器：当调用时会返回生成器对象支持迭代协议。当yield语句执行时运行时，会把结果返回给调用者让函数的状态挂起，然后调用 者再调用__next__方法时，这个函数就可以重新在上次yield语句后继续运行。
	生成器也可以用return语句用来终止生成器
5.map调用和list comprehension有什么关系？比较并对比两者。
	map调用类似于列表解析，两者都会收集对序列或其他可迭代对象中的每一个元素应用运算后的结果（一次一个项目），从而创建新的列表。其主要差异在于，map会对每个元素应用函数，而列表解析则是应用任意的表达式。因此列表解析更通用一些，可以像map那样应用函数调用表达式，但是，map需要一个函数才能应用其他种类的表达式。列表解析也支持扩展语法，例如嵌套for循环和if语句
```

**模块**

```http
1.模块源代码文件是怎样变成模块对象的？
	模块的源代码文件在模块导入时，就会自动生成模块对象。而这个过程中赋值的所有变量名都会生成模块对象的属性
2.为什么需要设置PYTHONPATH环境变量？
	只需设置PYTHONPATH,从而可以从正在用的目录（也就是正在交互模式下使用的当前目录，或者包含顶层文件的目录）以外的其他目录进行导入
3.举出模块导入搜索路径的四个主要组件。
	主目录（包含该文件的目录）、列在PYTHONPATH环境变量中的所有目录、标准链接库目录以及位于标准位置中.pth路径文件中的所有目录。
4.举出Python可能载入的能够响应import操作的四种文件类型。
	可能载入源代码文件（.py）、字节码文件（.pyc）、C扩展模块（os.文件以及windows的.dlll或.pyd）以及相同变量名的目录（用于包的导入）
5.什么是命名空间？模块的命名空间包含了什么？
	命名空间是一种独立完备的变量包，而变量就是命名空间对象的属性。
	模块的命名空间包含了代码在模块文件顶层赋值的所有变量名（也就是没有嵌套于def或class语句中）。模块的全局作用域会变成模块对象的属性命名空间。

```

```http
6.怎么创建模块？
	要创建模块时，只需要编写一个包含Python语句的文本文件就可以了：每个源代码文件都会自动成为模块，而且也没有语法用来声明模块。导入操作会把模块文件加载到内存中使其成为模块对象。命名的时候必须按照Python的命名规范
7.from语句和import语句有什么关系？
	from语句是导入整个模块，就像import语句那样，但是还有个步骤，就是会从被导入的模块中，复制一个或多个变量到from语句所在的作用域中。
	from time import sleep
	这样可以让你直接使用被导入的变量名（sleep）;
	import time
	而不是通过模块来使用变量名（time.sleep）
8.reload函数和导入有什么关系？
	默认，模块是每个进程只导入一次
	reload函数会强制模块再次被导入，基本上都是用于开发过程选取模块源代码的新版本，或者用在动态定制的场景中
9.什么时候必须使用import，不能使用from？
	当需要读取两个不同模块中的相同变量名时，就必须使用import：因为你必须制定变量名所在模块，从而保证这两个变量名时独特的。
10.请列举出from语句三种潜在陷阱。
	from语句会让变量含义模糊（究竟是哪个模块定义的），通过reload调用时会有问题（变量名还是引用对象之前的版本），而且会破坏命名空间（可能悄悄覆盖正在作用域中使用的变量名）。from* 形式在多数情况下都很糟糕：它会严重地污染命名空间，让变量意义变得模糊
```

```http
	
11.模块包目录内的__init__.py文件有何用途？
	__init__.py文件是用于声明和初始化模块包的。
	第一次在进程中导入某目录时，Python会自动运行这个文件中的代码。其赋值的变量会变成对应于该目录在内存中所创建的模块对象的属性。它不是选用的：如果一个目录中没有包含这个文件，是无法通过包语法导入目录的。
12.每次引用包的内容时，如何避免重复包的完整路径？
	通过from语句使用包，直接把包的变量名复制出来，或者使用import语句的as扩展功能，把路径改成比较短的别名。
	这种情况下，路径只出现在一个地方，就在from或import语句中
13.哪些目录需要__init__.py文件？
	import或from语句中所列出的每个目录都必须含有__init__.py文件。
	其他目录则不需要包含这个文件，包括含有包路径最左侧组件的目录。
14.在什么情况下必须通过import而不能通过from使用包？
	只有在你需要读取定义在一个以上路径的相同变量名时，才必须通过import来使用包，而不能使用from。使用import，路径可以让引用独特化，然而，from却让任何变量名只有一个版本。
15.from mypkg import spam和 from . import spam有什么差别？
	from mypkg import spam是绝对导入：mypkg的搜索掠过包路径并且mypkg位于sys.path中的一个绝对目录中。
    from . import spam是相对导入：spam的查找是相对于该语句所在的包，然后才会去搜索sys.path
```

```http
16.模块顶层以下划线开头的变量的重要性是什么？
	模块顶层变量名以单个下划线开头时，当使用from* 语句形式导入，这些变量名不会被复制到进行导入的作用域中。不过这些变量名还是可以通过import或者普通的from语句形式来导入。
17.当模块的__name__变量是字符串'__main__'时，代表了什么意义？
	如果模块的__name__变量是字符串'__main__',代表了该文件是作为顶层脚本运行的，而不是被程序中的另一个文件所导入的。也就是说这个文件作为程序在使用，而不是一个库
18.如果用户通过交互模式输入模块的变量进行测试，你该怎样进行导入？
	用户输入脚本时通常作为字符串。要通过字符串名导入所引用的模块，你可以创建import语句并通过exec执行，或者把字符串名传给__import__函数进行调用。
19.改变sys.path和设置PYTHONPATH来修改模块搜索路径有什么不同？
	修改sys.path只会影响一个正在运行的程序，是暂时的，当程序结束时，修改就会消失。PYTHONPATH设置是存在于操作系统中的，机器上所有程序都会使用，而且对这些设置的修改在程序离开后还会保存
20.如果模块__future__可让我们导入未来，我们也能导入过去吗？
	不能，我们无法在Python中导入过去，我们可以安装（或顽固的使用）这门语言的旧版本，但是，最新的Python往往是最好的。
	模块__future__：Python的每个新版本都会增加一些新的功能，或者对原来的功能作一些改动。
```

**面向对象**

```http
1.python的OOP的重要意义是什么？
	OOP就是代码的重用：分解代码、最小化代码的冗余以及对现存的代码进行定制来编写程序，而不是实地修改代码，或者从头开始。
2.继承搜索在哪里查找属性？
	继承搜索会先在实例对象中找属性，然后才是创建实例的类，之后是所有较高的超类，由对象树底端到顶端，并且从左侧至右侧（默认）。当属性首次找到时，搜索就会停止。因为在此过程中变量名的最低的版本会获胜，类的层次自然而然的支持了通过扩展进行代码的定制。
3.类对象和实例对象有什么不同？
	类和实例对象都是命名空间（由作为属性的变量的包）。两者间主要差别是，类是建立多个实例的工厂。类也支持运算符重载方法，由实例继承，而且把其中的任何函数视为处理实例的特殊的方法。
4.为什么类方法函数中的第一个参数特殊？
	类方法函数中的第一个参数之所以特殊，是因为它总是接受将方法调用视为隐含主体的实例对象。按惯例通常称为self，因为方法函数默认总是有个隐含的主体对象环境，所以我们说这是'面向对象'，也就是设计用来处理或修改对象的。
5.__init__方法是做什么的？
	如果类中编写了或继承了__init__方法，每次类实例创建时，Python会自动调用它。这也称为构造函数。除了明确传入类的名称的任何参数外，还会隐性的传入新实例。这也是最常见的运算符重载方法。如果没有__init__方法，实例刚创建时就是一个简单的空的命名空间。
6.怎样创建类实例？
	调用类名称（就好像函数一样）来创建类实例。任何传给类名称的参数都要出现在__init__构造函数中第二和其后的参数。新的实例会记得创建它的类，从而可以实现继承目的。
	
7.怎样创建类？
	Class语句来创建，就像定义函数一样，这些语句在所在的模块文件导入时，一般就会运行
8.怎样定义类的超类？
	定义一个类的超类是通过在Class语句的圆括号中将其列出，也就是在新的类名称后。类在圆括号中由左至右列出的顺序，会决定其在类树中由左至右的搜索的顺序
```

```http
9.类和模块之间有什么关系？
	类总是位于模块中：类是模块对象的属性。
	类和模块都是命名空间，但是类对应于语句（而不是整个文件），而且支持多个实例、继承以及运算符重载这些OOP概念。总之，模块就像是单个的实例类，没有继承，而且模块对应于整个文件的代码。
10.实例和类是怎么创建的？
	类是通过运行Class语句创建的：实例是像函数那样调用类来创建的。
11.类属性是在哪里创建的？是怎样创建的？
	类属性的创建是通过把属性赋值给类对象实现的。
	类属性通常是由Class语句中的顶层赋值语句产生的：每个在Class语句代码区中赋值的变量名，会变成类对象的属性（从技术角度来讲，Class语句的作用域会变成类对象的属性的命名空间）。不过，也可以于任何引用类对象的地方（在Class语句外）对其属性赋值，从而也可以创建类属性。
12.实例属性是在哪里创建的？是怎样创建的？
	实例属性是通过对实例对象赋值属性来创建的。
	实例属性一般是在Class语句中的类方法函数中self参数（永远是隐含实例）赋值属性而创建的。不过你也可以在任何地方引用实例通过赋值语句来创建属性，即使是在Class语句外。一般来说，所有实例属性都是在__init__构造函数中初始化的，这样的话，之后的方法调用都可以假设属性已经存在。
13.Python类中的self有什么意义？
	self通常是给与类方法函数中的第一个（最左侧）参数的名称：Python会自动填入实例对象（也就是方法调用的隐含的主体）。这个参数不必叫self，其位置才是重点
14.Python类中如何编写运算符重载？
	Python类中的运算符重载是用特定名称的方法写成的。这些方法的开头和结尾都是双下划线，通过这种办法使其变得独特。这些不是内置或保留字。当实例出现在相应的运算中时，Python就会自动执行它们。Python为这些运算和特殊方法的名称定义了对应关系。
15.什么时候可能在类中支持运算符重载？
	运算符重载可用于实现模拟内置类型的对象（例如，序列或矩阵这样的数值对象），以及模拟代码中所预期的内置类型接口。模拟内置类型的接口可让你传入具有状态信息（也就是记住操作调用之间数据的属性）的类实例。不过，当简单命名的方法就够用时，不应该使用运算符重载。
16.哪个运算符重载方法是最常用的？
	__init__构造函数是最常用的。
	几乎每个类都使用这个方法为实例属性进行初始化，以及执行其他的启动任务。
17.Python OOP程序代码中最重要的两个概念是什么？
	方法函数中的特殊self参数和__init__构造函数是Python中的OOP的两个基石。
	
```

**实例**

```
1.当我们从shelve获取一个Manager对象并打印它的时候，显示格式逻辑来自何处？
2.当我们从一个shelve获取一个Person对象而没有导入其模块的时候，该对象如何知道它有一个giveRaise方法可供我们调用？
3.为什么把处理放入方法中而不是在类之外的硬编码如此重要？
4.为什么通过子类而不是复制并修改最初的代码来定制会更好？
5.为什么回调一个超类的方法来运行默认操作而不是在子类中复制和修改其代码要更好？
```

